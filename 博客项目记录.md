## 博客系统（blog-api）

### 概述

- application.properties中com.mysql.cj.jdbc.Driver报错

  注释了所有不带版本的依赖

- tag查询时要多表查询，但是mybatis-plus不支持多表查询，于是手写了mapper、sql

- 使用了idea的myabtisx插件

### 显示文章列表功能

- mapper都extends BaseMapper< Article>，这是为什么，BaseMapper是mybatis-plus的API，我们可以不用写sql了，继承该类的mapper，我们可以直接调用其方法
- ArticleServiceImpl中调用myabtis-plus的API去进行分页，用到了Wrapper

- ArticleServiceImpl中，从数据库中分页查出的article数据records能直接返回吗，明显不能

  因为数据库中的字段不一定要全部显示到前端，所以新建了一个实体类ArticleVo（vo：view object，表示视图层的数据）

  同时，数据库查到了数据后，调用自定义的 copyList方法，将整个List< Article>化为List< ArticleVo>

- ArticleServiceImpl中，上述几项没有涉及到下方标签和作者，如下图。

  ![image-20220302222713522](C:/Users/张渭/AppData/Roaming/Typora/typora-user-images/image-20220302222713522.png)

  于是再去扩展这个功能，定义了SysUserService、SysUserServiceImpl、TagService、TagServiceImpl,直接调用，这里不用自己写sql

> 用户表中avator是头像的意思

### 最热标签功能

最热标签：标签所拥有的文章数量最多

数据表两张

![image-20220303163603605](https://gitee.com/developingcoder/img/raw/master/img/image-20220303163603605.png)

![image-20220303163612093](https://gitee.com/developingcoder/img/raw/master/img/image-20220303163612093.png)

```sql
查询文章数量最多3个的标签的id
select tag_id,count(*) as cnt from ms_article_tag group by tag_id order by cnt desc limit 3;

根据ids查询标签的名字
select tag_name,id from ms_tag where id in
(select tag_id  from ms_article_tag group by tag_id order by count(*) desc)
```

- TagsController的hot方法跳转
- 编写sql，使用动态sql进行子查询

```sql
<select id="findTagsByTagIds" parameterType="list" resultType="top.ambtwill.blog.dao.pojo.Tag">
    select id,tag_name as tagName from ms_tag
    where id in
    <foreach collection="tagIds" item="tagId" separator="," open="(" close=")">
        #{tagId}
    </foreach>
</select>
```

### 统一异常处理

不管是controller层还是service，dao层，都有可能报异常，如果是预料中的异常，可以直接捕获处理，如果是意料之外的异常，需要统一进行处理，进行记录，并给用户提示相对比较友好的信息。

在包Handler下编写 类AllExceptionHandler，进行异常处理

客户端就接受到如下的数据：友好

![image-20220303164801044](https://gitee.com/developingcoder/img/raw/master/img/image-20220303164801044.png)

### 最热文章

/articles/hot POST

控制器中调用articleService.hotArticle方法，使用mybatis-plus的API配合wrapper。注意：limit后面要加空格

效果如下：

![image-20220303170421813](https://gitee.com/developingcoder/img/raw/master/img/image-20220303170421813.png)

### 最新文章

/articles/new POST

和最热文章基本一样

### 文章归档

接口url：/articles/listArchives

请求方式：POST

```sql
select year(FROM_UNIXTIME(create_date/1000)) as year ,
        month(FROM_UNIXTIME(create_date/1000)) as month,
        count(*) as count
from ms_article group by year,month;
```

注意：文章表中的创建时间不是日期个格式，而是时间戳格式，是一个大整数，在sql中不能通过函数year()获得时间的年份（返回null），要通过如下方式去调用year()

```
year(FROM_UNIXTIME(create_date/1000))
```

[MySQL中 Bigint类型无法通过year函数直接转换](https://www.cnblogs.com/weiambt/articles/15961493.html)

- sql中的查询结果必须要和实体类中属性类型要一致

### 登录功能

接口url：/login

请求方式：POST

请求参数：

| 参数名称 | 参数类型 | 说明 |
| -------- | -------- | ---- |
| account  | string   | 账号 |
| password | string   | 密码 |
|          |          |      |

返回数据：

~~~json
{
    "success": true,
    "code": 200,
    "msg": "success",
    "data": "token"
}
~~~

#### JWT

登录使用JWT技术。

jwt 可以生成 一个加密的token，做为用户登录的令牌，当用户登录成功之后，发放给客户端。

请求需要登录的资源或者接口的时候，将token携带，后端验证token是否合法。

jwt 有三部分组成：A.B.C

A：Header，{"type":"JWT","alg":"HS256"} 固定

B：playload，存放信息，比如，用户id，过期时间等等，可以被解密，不能存放敏感信息

C:  签证，A和B加上秘钥 加密而成，只要秘钥不丢失，可以认为是安全的。

jwt 验证，主要就是验证C部分 是否合法。



依赖包:

~~~xml
  <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt</artifactId>
        <version>0.9.1</version>
    </dependency>
~~~



工具类:

~~~java
public class JWTUtils {

    private static final String jwtToken = "123456Mszlu!@#$$";

    // 创建令牌
    public static String createToken(Long userId){
        Map<String,Object> claims = new HashMap<>();
        claims.put("userId",userId);
        JwtBuilder jwtBuilder = Jwts.builder()
                .signWith(SignatureAlgorithm.HS256, jwtToken) // 签发算法，秘钥为jwtToken
                .setClaims(claims) // body数据，要唯一，自行设置
                .setIssuedAt(new Date()) // 设置签发时间
                .setExpiration(new Date(System.currentTimeMillis() + 24 * 60 * 60 * 60 * 1000));// 一天的有效时间
        String token = jwtBuilder.compact();
        return token;
    }

    // 检查令牌
    public static Map<String, Object> checkToken(String token){
        try {
            Jwt parse = Jwts.parser().setSigningKey(jwtToken).parse(token);
            return (Map<String, Object>) parse.getBody();
        }catch (Exception e){
            e.printStackTrace();
        }
        return null;
    }

    public static void main(String[] args) {
        String token = JWTUtils.createToken(100l);
        System.out.println(token);
        Map<String, Object> map = JWTUtils.checkToken(token);
        System.out.println(map.get("userId"));
    }
}
~~~

#### 实现

步骤： 

1. 检查参数是否合法

2. 根据用户名和密码去user中查询是否存在

3. 不存在，登录失败

4. 存在，使用JWT生成TOKEN 返回给前端

5. token放入redis中，redis存储 token:user信息 设置过期时间

   （登录认证的时候，先验证token，去redis认证是否存在）

> 登录功能没写在SysUserService中写，而是重新创建了一个LoginService，降低耦合

LoginController、LoginService省略

登录业务LoginServiceImpl

```java
@Service
public class LoginServiceImpl implements LoginService {
    @Autowired
    private SysUserService sysUserService;
    @Autowired
    private RedisTemplate<String,String> redisTemplate;

    //盐
    private static final String salt = "zwzww!@W#";

    @Override
    public Result login(LoginParam loginParam) {
        /**
         * 1.检查参数是否合法
         * 2.根据用户名和密码去user中查询是否存在
         * 3.不存在，登录失败
         * 4.存在，使用JWT生成TOKEN 返回给前端
         * 5.token放入redis中，redis存储 token:user信息 设置过期时间
         * （登录认证的时候，先验证token，去redis认证是否存在）
         */
        String account = loginParam.getAccount();
        String password = loginParam.getPassword();
        if(StringUtils.isBlank(account) || StringUtils.isBlank(password))
            return Result.fail(ErrorCode.PARAMS_ERROR.getCode(),ErrorCode.PARAMS_ERROR.getMsg());
        //加密
        // password = DigestUtils.md5Hex((password + salt));
        password = DigestUtils.md5DigestAsHex((password + salt).getBytes());
        // System.out.println(password);
        SysUser sysUser =  sysUserService.findUser(account,password);

        if(sysUser == null){
            return Result.fail(ErrorCode.ACCOUNT_PWD_NOT_EXIST.getCode(),ErrorCode.ACCOUNT_PWD_NOT_EXIST.getMsg());
        }
        String token = JWTUtils.createToken(sysUser.getId());
        redisTemplate.opsForValue().set("TOKEN_"+token, JSON.toJSONString(sysUser),1, TimeUnit.DAYS);//1是时间
        return Result.success(token);
    }

    //生成用户账号密码
    @Test
    public void createSysUser(){
        //自定义用户名、密码
        String userId="root";
        String password="root";
        //md5加密生成密码
        String md5Password = DigestUtils.md5DigestAsHex((password + salt).getBytes());
        System.out.println("userId="+userId);
        System.out.println("password="+password);
        System.out.println("md5Password="+md5Password);
    }
}
```

登录参数类放在包vo.params的LoginParam中

```
@Data
public class LoginParam {
    private String account;

    private String password;
}
```

redis配置

```
spring.redis.host=localhost
spring.redis.port=6379
```

创建错误码类，统一管理

```java
package top.ambtwill.blog.vo;

public enum  ErrorCode {

    PARAMS_ERROR(10001,"参数有误"),
    ACCOUNT_PWD_NOT_EXIST(10002,"用户名或密码不存在"),
    NO_PERMISSION(70001,"无访问权限"),
    SESSION_TIME_OUT(90001,"会话超时"),
    NO_LOGIN(90002,"未登录"),;

    private int code;
    private String msg;

    ErrorCode(int code, String msg){
        this.code = code;
        this.msg = msg;
    }

    public int getCode() {
        return code;
    }

    public void setCode(int code) {
        this.code = code;
    }

    public String getMsg() {
        return msg;
    }

    public void setMsg(String msg) {
        this.msg = msg;
    }
}
```

>  登录功能要用接口测试工具去测，如果用前端测会循环报错

#### 面试题：字符串判空API

StringUtils.isBlank()

https://blog.csdn.net/qq_43673190/article/details/84401437

https://www.cnblogs.com/dennisit/p/3705374.html

### 获取登录用户信息

该功能在用户登录后，自动调用这个功能，根据TOKEN获取用户信息

接口url：/users/currentUser

请求方式：GET

请求参数：

| 参数名称      | 参数类型 | 说明            |
| ------------- | -------- | --------------- |
| Authorization | string   | 头部信息(TOKEN) |
|               |          |                 |
|               |          |                 |

编写controller

```java
@RestController
@RequestMapping("/users")
public class UserController {
    @Autowired
    private SysUserService sysUserService;

    /**
     * 获取登录用户信息（根据Token）
     * @param token
     * @return
     */
    @GetMapping("/currentUser")
    public Result currentUser(@RequestHeader("Authorization") String token){
        return sysUserService.getUserInfoByToken(token);
    }
}
```

在SysUserServiceImpl中编写如下语句：

```java
@Autowired
private RedisTemplate<String,String> redisTemplate;

/**
 * 根据Token查看用户信息
 * @return
 */
@Override
public Result getUserInfoByToken(String token) {
    System.out.println("后"+token);
    Map<String, Object> map = JWTUtils.checkToken(token);
    if (map == null){
        return Result.fail(ErrorCode.NO_LOGIN.getCode(),ErrorCode.NO_LOGIN.getMsg());
    }

    String userJson = redisTemplate.opsForValue().get("TOKEN_" + token)+"";
    // System.out.println("userJson:"+userJson);
    // System.out.println("StringUtils.isBlank:"+StringUtils.isBlank(userJson));
    if (StringUtils.isBlank(userJson)){
        System.out.println("userJson==null");
        return Result.fail(ErrorCode.NO_LOGIN.getCode(),ErrorCode.NO_LOGIN.getMsg());
    }
    SysUser sysUser = JSON.parseObject(userJson, SysUser.class);
    System.out.println("sysUser:"+sysUser);
    LoginUserVo loginUserVo = new LoginUserVo();
    loginUserVo.setAccount(sysUser.getAccount());
    loginUserVo.setAvatar(sysUser.getAvatar());
    loginUserVo.setId(sysUser.getId());
    loginUserVo.setNickname(sysUser.getNickname());
    return Result.success(loginUserVo);
}
```

> 这里和视频里不一样，视频中是调用SysuserService中的checkToken方法,而我们没有这个方法，是因为我们把该方法的逻辑直接拿到外面来写了，这里对后面的功能有影响

> 注意：redisTemplate一定要加泛型，不然会拿不到数据

#### 循环报错【bug】

redis中存在这个TOKEN，但是在java中却get不到这个TOKEN

![image-20220307203555986](https://gitee.com/developingcoder/img/raw/master/img/image-20220307203555986.png)

![image-20220307204131796](https://gitee.com/developingcoder/img/raw/master/img/image-20220307204131796.png)

错误点：【已解决】

- SysUserServiceImpl的84行，无法redistemplate中get到，永远get到为null

  原因：redistemplate没有写泛型！！！


### 退出登录

接口url：/logout

请求方式：GET

请求参数：

| 参数名称      | 参数类型 | 说明            |
| ------------- | -------- | --------------- |
| Authorization | string   | 头部信息(TOKEN) |
|               |          |                 |
|               |          |                 |

返回数据：

~~~json
{
    "success": true,
    "code": 200,
    "msg": "success",
    "data": null
}
~~~

controller

```
@RestController
@RequestMapping("logout")
public class LogoutController {

    @Autowired
    private LoginService loginService;

    @GetMapping
    public Result logout(@RequestHeader("Authorization") String token){
        return loginService.logout(token);
    }
}
```

service

```
  @Override
    public Result logout(String token) {
        redisTemplate.delete("TOKEN_"+token);
        return Result.success(null);
    }
```

### 注册功能

> 用户注册成功后，生成Token，放入redis中，返回一个Token
> 这样就意味着如果注册成功，Token会返回给前端，而前端的代码是会一直调用《获取用户信息功能》，这样就自动登录了

接口url：/register

请求方式：POST

请求参数：

| 参数名称 | 参数类型 | 说明 |
| -------- | -------- | ---- |
| account  | string   | 账号 |
| password | string   | 密码 |
| nickname | string   | 昵称 |

返回数据：

~~~json
{
    "success": true,
    "code": 200,
    "msg": "success",
    "data": "token"
}
~~~

controller

```java
@RestController
@RequestMapping("/register")
public class RegisterController {
    @Autowired
    private LoginService loginService;

    @PostMapping
    public Result register(@RequestBody LoginParam loginParam){
        return loginService.register(loginParam);
    }
}
```

参数LoginParam中 添加新的参数nickname

```
@Data
public class LoginParam {

    private String account;

    private String password;

    private String nickname;
}
```

LoginService

```
Result register(LoginParam loginParam);
```

```java
/**
 * 注册功能
 * @param loginParam
 * @return
 */
@Override
public Result register(LoginParam loginParam) {
    //1.获取数据，判断合法性
    //2.查询数据库，有则返回已注册
    //3.没有则添加到数据库
    //4.生成token，加入redis
    //5.返回token
    String account = loginParam.getAccount();
    String password = loginParam.getPassword();
    String nickname = loginParam.getNickname();
    if(StringUtils.isBlank(account)
            || StringUtils.isBlank(password)
            || StringUtils.isBlank(nickname))
        return Result.fail(ErrorCode.PARAMS_ERROR.getCode(),ErrorCode.PARAMS_ERROR.getMsg());

    SysUser sysUser = sysUserService.findUserByAccount(account);
    if(sysUser!=null){
        return Result.fail(ErrorCode.ACCOUNT_EXIST.getCode(),ErrorCode.ACCOUNT_EXIST.getMsg());
    }
    sysUser = new SysUser();
    sysUser.setNickname(nickname);
    sysUser.setAccount(account);
    sysUser.setPassword(DigestUtils.md5DigestAsHex((nickname+salt).getBytes()));
    sysUser.setCreateDate(System.currentTimeMillis());
    sysUser.setLastLogin(System.currentTimeMillis());
    sysUser.setAvatar("/static/img/logo.b3a48c0.png");
    sysUser.setAdmin(1); //1 为true
    sysUser.setDeleted(0); // 0 为false
    sysUser.setSalt("");
    sysUser.setStatus("");
    sysUser.setEmail("");
    this.sysUserService.save(sysUser);//保存到数据库

    //生成Token
    String token = JWTUtils.createToken(sysUser.getId());
    redisTemplate.opsForValue().set("TOKEN_"+token, JSON.toJSONString(sysUser),1, TimeUnit.DAYS);//1是时间

    return Result.success(token);
}
```

ErrorCode中新增属性：

```
ACCOUNT_EXIST(10004,"账号已存在"),
```

SysUserService：

```
 SysUser findUserByAccount(String account);
 void save(SysUser sysUser);
```

```java
@Override
public SysUser findUserByAccount(String account) {
    LambdaQueryWrapper<SysUser> queryWrapper = new LambdaQueryWrapper<>();
    queryWrapper.eq(SysUser::getAccount,account);
    queryWrapper.last("limit 1");
    return sysUserMapper.selectOne(queryWrapper);
}

@Override
public void save(SysUser sysUser) {
    //注意 默认生成的id 是分布式id 采用了雪花算法
    this.sysUserMapper.insert(sysUser);
}
```
#### 加事务

如果不加事务，那么如果在注册逻辑中某一步报错，数据依然能够保存到数据库，这不是我们希望的，下面来模拟异常。

1. 取消LoginServiceImpl类的@Transactional修饰

2. redis数据库不打开

3. 这样注册时就会报错

   ![image-20220312122603370](C:\Users\张渭\AppData\Roaming\Typora\typora-user-images\image-20220312122603370.png)

   ![image-20220312122530520](C:\Users\张渭\AppData\Roaming\Typora\typora-user-images\image-20220312122530520.png)

4. 查看数据库，发现数据依然添加成功

   ![image-20220312122631496](C:\Users\张渭\AppData\Roaming\Typora\typora-user-images\image-20220312122631496.png)

我们不希望这样

所以加上@Transactional，要么都成功，要么都失败，这样如果有异常就不会保存成功了

### 登录拦截器

每次访问需要登录的资源的时候，都需要在代码中进行判断，一旦登录的逻辑有所改变，代码都得进行变动，非常不合适。

那么可不可以统一进行登录判断呢？

可以，使用拦截器，进行登录拦截，如果遇到需要登录才能访问的接口，如果未登录，拦截器直接返回，并跳转登录页面。

handler包下建立LoginInterceptor拦截器

```java
//登录拦截器
@Component
@Slf4j
public class LoginInterceptor implements HandlerInterceptor {

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //在controller方法（Handler）执行之前执行
        /**
         * 1.判断接口请求是否为HandlerMethod（Controller方法）
         * 2.判断token是否为null，空则登录
         * 3.检查token,checkToken
         * 4.认证成功就放行
         */
        if (!(handler instanceof HandlerMethod)){//如果不是Controller方法,比如静态资源，直接放行
            return true;
        }
        String token = request.getHeader("Authorization");

        //日志
        log.info("=================request start===========================");
        String requestURI = request.getRequestURI();
        log.info("request uri:{}",requestURI);
        log.info("request method:{}",request.getMethod());
        log.info("token:{}", token);
        log.info("=================request end===========================");

        if (token == null){
            Result result = Result.fail(ErrorCode.NO_LOGIN.getCode(), "未登录");
            response.setContentType("application/json;charset=utf-8");
            response.getWriter().print(JSON.toJSONString(result));
            return false;
        }
        Map<String, Object> map = JWTUtils.checkToken(token);
        if (map == null){
            Result result = Result.fail(ErrorCode.NO_LOGIN.getCode(), "未登录");
            response.setContentType("application/json;charset=utf-8");
            response.getWriter().print(JSON.toJSONString(result));
            return false;
        }

        //是登录状态，放行
        //我希望在controller中 直接获取用户的信息 怎么获取?
        return true;
    }
}
```

去WebMVCConfig中加入

```java
	@Autowired
    private LoginInterceptor loginInterceptor;
/**
 * 配置拦截器，拦截所有需要登录才能访问的接口
 * @param registry
 */
@Override
public void addInterceptors(InterceptorRegistry registry) {
    registry.addInterceptor(loginInterceptor)
            .addPathPatterns("/test");
            // .addPathPatterns("/**")
            // .excludePathPatterns("/login").excludePathPatterns("/register")
            /*
            这里因为博客项目不太需要拦截，所以只采用test作为测试
            如果要配的话，使用上面注释的两句话，拦截所有接口，除了登录和注册
             */
}
```



测试

- 后端测试：http://localhost:8888/test

  结果：

  ![image-20220312171722720](C:\Users\张渭\AppData\Roaming\Typora\typora-user-images\image-20220312171722720.png)

  因为request header 中的Authorization没有数据，所以token为null，所以就返回未登录

- postman测试：http://localhost:8888/test

  登录页面获取到一个token

  将token加入Header参数

  ![image-20220312172857718](C:\Users\张渭\AppData\Roaming\Typora\typora-user-images\image-20220312172857718.png)

  ![image-20220312173006760](C:\Users\张渭\AppData\Roaming\Typora\typora-user-images\image-20220312173006760.png)

### ThreadLocal保存用户信息

在上一功能中，如果用户验证成功，那么会放行，怎么获取用户信息呢？使用ThreadLocal存储用户信息，记得要删除，不然会有内存泄漏的风险

修改LoginInterceptor

```java
//登录拦截器
@Component
@Slf4j
public class LoginInterceptor implements HandlerInterceptor {
    @Autowired
    private RedisTemplate<String,Object> redisTemplate;

    @Override
    public boolean preHandle(HttpServletRequest request, HttpServletResponse response, Object handler) throws Exception {
        //在controller方法（Handler）执行之前执行
        /**
         * 1.判断接口请求是否为HandlerMethod（Controller方法）
         * 2.判断token是否为null，空则登录
         * 3.检查token,checkToken
         * 4.认证成功就放行——>将用户的信息从redis中拿到并且给controller
         */
        if (!(handler instanceof HandlerMethod)){//如果不是Controller方法,比如静态资源，直接放行
            return true;
        }
        String token = request.getHeader("Authorization");

        //日志
        log.info("=================request start===========================");
        String requestURI = request.getRequestURI();
        log.info("request uri:{}",requestURI);
        log.info("request method:{}",request.getMethod());
        log.info("token:{}", token);
        log.info("=================request end===========================");

        if (token == null){
            Result result = Result.fail(ErrorCode.NO_LOGIN.getCode(), "未登录");
            response.setContentType("application/json;charset=utf-8");
            response.getWriter().print(JSON.toJSONString(result));
            return false;
        }

        Map<String, Object> map = JWTUtils.checkToken(token);
        if (map == null){
            Result result = Result.fail(ErrorCode.NO_LOGIN.getCode(), "未登录");
            response.setContentType("application/json;charset=utf-8");
            response.getWriter().print(JSON.toJSONString(result));
            return false;
        }

        //是登录状态，放行
        //我希望在controller中 直接获取用户的信息 怎么获取?
        String sysUserJson = redisTemplate.opsForValue().get("TOKEN_" + token)+"";
        SysUser sysUser = JSON.parseObject(sysUserJson, SysUser.class);
        UserThreadLocal.put(sysUser);
        return true;
    }

    @Override
    public void afterCompletion(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex) throws Exception {
        //如果不删除ThreadLocal中用完的信息，会有内存泄漏的风险
        UserThreadLocal.remove();
    }
}
```

修改TestController

```
@RestController
@RequestMapping("/test")
public class TestController {

    //用来测试登录拦截器、（Threadlocal）
    @GetMapping
    public Result ss(){
        SysUser sysUser = UserThreadLocal.get();
        System.out.println(sysUser);
        return Result.success(null);
    }
}
```

### ThreadLocal内存泄漏原理

![img](D:\桌面\博客项目\1-10\05\img\1855493-c1a3ca8e0fe6f67d-1623768918927.webp)

**实线代表强引用,虚线代表弱引用**

每一个Thread维护一个ThreadLocalMap, key为使用**弱引用**的ThreadLocal实例，value为线程变量的副本。

**强引用**，使用最普遍的引用，一个对象具有强引用，不会被垃圾回收器回收。当内存空间不足，Java虚拟机宁愿抛出OutOfMemoryError错误，使程序异常终止，也不回收这种对象。

**如果想取消强引用和某个对象之间的关联，可以显式地将引用赋值为null，这样可以使JVM在合适的时间就会回收该对象。**

**弱引用**，JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。在java中，用java.lang.ref.WeakReference类来表示。

> 每一个Thread维护一个ThreadLocalMap，key是弱引用，经过一次垃圾回收，key被回收了，线程还存在，value还存在，此时的情况就是在一个map中，key被回收了，但是value还存在，无法找到value，value永远无法被删除。所以要显式的给他清楚，这样就没有了内存泄漏的风险了



### 文章详情（稍复杂）

接口url：/articles/view/{id}

请求方式：POST

请求参数：

| 参数名称 | 参数类型 | 说明               |
| -------- | -------- | ------------------ |
| id       | long     | 文章id（路径参数） |
|          |          |                    |
|          |          |                    |

返回数据：

~~~json
{
    "success": true,
    "code": 200,
    "msg": "success",
    "data": "token"
}
~~~

涉及到的表：

```
import lombok.Data;

@Data
public class ArticleBody {

    private Long id;
    private String content;
    private String contentHtml;
    private Long articleId;
}
```

```
@Data
public class Category {

    private Long id;

    private String avatar;

    private String categoryName;

    private String description;
}
```

controller

```
/**
 * 文章详情
 * @param id
 * @return
 */
@PostMapping("/view/{id}")
public Result findArticle(@PathVariable("id") Long id){
    ArticleVo articleVo = articleService.findArticleById(id);
    return Result.success(articleVo);
}
```

service

```
/**
 * 查看文章详情
 * @param id
 * @return
 */
ArticleVo findArticleById(Long id);
```

```
@Override
public ArticleVo findArticleById(Long id) {
    Article article = articleMapper.selectById(id);
    return  copy(article,true,true,true,true);
}
```

> 这边重载了之前的copy方法（增加了两个参数）

涉及的方法:

```
@Autowired
private CategoryService categoryService;
@Autowired
private ArticleBodyMapper articleBodyMapper;
public ArticleVo copy(Article article, Boolean isTag,Boolean isAuthor, Boolean isBody, Boolean isCategory){
    ArticleVo articleVo = new ArticleVo();
    BeanUtils.copyProperties(article,articleVo);//Spring的

    articleVo.setCreateDate(new DateTime(article.getCreateDate()).toString("yyyy-MM-dd HH:mm"));
    if(isTag){
        Long articleId = article.getId();
        articleVo.setTags(tagService.findTagsByArticleId(articleId));
    }

    if(isAuthor){
        Long authorId = article.getAuthorId();
        articleVo.setAuthor(sysUserService.findUserById(authorId).getNickname());
    }

    if (isBody){
        Long articleId = article.getId();
        articleVo.setBody(findArticleBody(articleId));
    }

    if(isCategory){
        Long categoryId = article.getCategoryId();
        CategoryVo categoryVo = categoryService.findCategoryById(categoryId);
        articleVo.setCategorys(Arrays.asList(categoryVo));//与笔记不一样
    }
    return articleVo;
}
//copy函数调用
private ArticleBodyVo findArticleBody(Long articleId) {
    LambdaQueryWrapper<ArticleBody> queryWrapper = new LambdaQueryWrapper();
    queryWrapper.eq(ArticleBody::getArticleId,articleId);

    ArticleBody articleBody = articleBodyMapper.selectOne(queryWrapper);

    ArticleBodyVo articleBodyVo = new ArticleBodyVo();
    if(articleBody.getContent()!=null)//set方法的值为null会报空指针异常
        articleBodyVo.setContent(articleBody.getContent());
    //或者 BeanUtils.copyProperties(articleBody,articleBodyVo);
    return articleBodyVo;
}
```

涉及的视图实体

```
@Data
public class CategoryVo {

    private Long id;

    private String avatar;

    private String categoryName;
}
```

```
@Data
public class ArticleBodyVo {

    private String content;
}

```

涉及的Category和ArticleBody

```
public interface CategoryService {

    CategoryVo findCategoryById(Long id);
}
```

```
@Service
public class CategoryServiceImpl implements CategoryService {
    @Autowired
    private CategoryMapper categoryMapper;


    @Override
    public CategoryVo findCategoryById(Long categoryId) {
        Category category = categoryMapper.selectById(categoryId);
        CategoryVo categoryVo = new CategoryVo();
        BeanUtils.copyProperties(category,categoryVo);
        return categoryVo;
    }
}
```

```
@Mapper
@Repository
public interface ArticleBodyMapper extends BaseMapper<ArticleBody> {
}
```

```
@Mapper
@Repository
public interface CategoryMapper extends BaseMapper<Category> {
}
```

> 异常处理：
>
> 如果不加ArticleVo上面不加注解@JsonSerialize，那么会报错
>
> ```
> // @JsonSerialize(using = ToStringSerializer.class)
> private Long id;
> ```
>
> 原因：雪花算法出现精读问题：https://www.cnblogs.com/weiambt/articles/16003596.html

### 更新阅读次数（线程池）

这个需求紧跟着上一个文章详情的功能后面，我们查看文章的详情后，需要更新这篇文章的浏览量+1。

查看完文章信息，本应该直接返回数据，这时需要进行更新操作，更新操作在数据库中会加写锁，阻塞其他读的操作，性能会比较低。此外，在这个查看文章详情的接口中，新增更新需求，会影响性能。比如，我只是想查看文章，但是你只是更新浏览量导致报错，导致我不能看文章详情，非常不合理。

优化方法就是：线程池技术

可以把更新操作放到线程池中执行，和主线程就无关了

线程池配置类：

```java
@Configuration
@EnableAsync//开启多线程
public class ThreadPoolConfig {

    @Bean("taskExecutor")
    public Executor asyncServiceExecutor() {
        ThreadPoolTaskExecutor executor = new ThreadPoolTaskExecutor();
        // 设置核心线程数
        executor.setCorePoolSize(5);
        // 设置最大线程数
        executor.setMaxPoolSize(20);
        //配置队列大小
        executor.setQueueCapacity(Integer.MAX_VALUE);
        // 设置线程活跃时间（秒）
        executor.setKeepAliveSeconds(60);
        // 设置默认线程名称
        executor.setThreadNamePrefix("码神之路博客项目");
        // 等待所有任务结束后再关闭线程池
        executor.setWaitForTasksToCompleteOnShutdown(true);
        //执行初始化
        executor.initialize();
        return executor;
    }
}
```

service包下新建类ThreadService：

```java
@Service
public class ThreadService {
    
    //此更新在线程池中进行
    @Async("taskExecutor")//异步
    public void updateArticleViewCount(ArticleMapper articleMapper, Article article) {

        //update article set viewCounts = 100 where viewCounts = 99 and id = ?
        Article articleUpdate = new Article();
        articleUpdate.setViewCounts(article.getViewCounts()+1);
        LambdaQueryWrapper<Article> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(Article::getId,article.getId());
        queryWrapper.eq(Article::getViewCounts,article.getViewCounts());//乐观锁,在多线程的情况下保证线程安全

        articleMapper.update(articleUpdate,queryWrapper);

        try {
            Thread.sleep(5000);
            System.out.println("更新成功...");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }
    }
}
```

在findArticleById方法中添加语句：

```java
@Override
public ArticleVo findArticleById(Long id) {
    //查看文章
    Article article = articleMapper.selectById(id);
    ArticleVo articleVo = copy(article, true, true, true, true);

    //更新浏览量,使用线程池
    threadService.updateArticleViewCount(articleMapper,article);

    return articleVo;
}
```



> 体验：
>
> - 没有线程池时：
>
>   ```
>   public void updateArticleViewCount(ArticleMapper articleMapper, Article article) {
>   
>       try {
>           Thread.sleep(5000);
>           System.out.println("更新成功...");
>       } catch (InterruptedException e) {
>           e.printStackTrace();
>       }
>   }
>   ```
>
>   查看文章详情，发现文章无法显示，5秒后，控制台输出更新成功，才显示了文章详情
>
> - 使用线程池
>
>   配置ThreadPoolConfig后，方法上加上注解
>
>   ```
>   @Async("taskExecutor")//异步
>   public void updateArticleViewCount(ArticleMapper articleMapper, Article article) {
>   
>       try {
>           Thread.sleep(5000);
>           System.out.println("更新成功...");
>       } catch (InterruptedException e) {
>           e.printStackTrace();
>       }
>   }
>   ```
>
>   查看文章详情，文章立刻显示了，5秒后，控制台输出更新成功

这里的次数更新后，自己不是立刻能看到，数据库已经更新了，我们保证下次别人看到就行了。

我们遇到了新的问题......

### 异常处理

在更新阅读次数的功能中，我们的sql语句竟然莫名其妙的多了2个字段，即comment_counts和weight，并且将他们设置为0，如下图：

![image-20220314153636506](C:\Users\张渭\AppData\Roaming\Typora\typora-user-images\image-20220314153636506.png)

原因就是在之前实体类中的变量类型定义成了基本数据类型，之前Article中的commentCounts，viewCounts，weight 字段为int，会造成更新阅读次数的时候，将其余两个字段设为初始值0。（int初始值为0）

使用mybatis-plus的时候，只要属性的值不为null，就会生成到sql语句中，0不是Null,所以加入了sql中。

解决方法是，换成包装类（包装类默认初始值为Null）

> 所有的实体类都要用包装类

### 评论列表

接口url：/comments/article/{id}

请求方式：GET

请求参数：

| 参数名称 | 参数类型 | 说明               |
| -------- | -------- | ------------------ |
| id       | long     | 文章id（路径参数） |
|          |          |                    |
|          |          |                    |

返回数据：

~~~json
{
    "success": true,
    "code": 200,
    "msg": "success",
    "data": [
        {
            "id": 53,
            "author": {
                "nickname": "李四",
                "avatar": "http://localhost:8080/static/img/logo.b3a48c0.png",
                "id": 1
            },
            "content": "写的好",
            "childrens": [
                {
                    "id": 54,
                    "author": {
                        "nickname": "李四",
                        "avatar": "http://localhost:8080/static/img/logo.b3a48c0.png",
                        "id": 1
                    },
                    "content": "111",
                    "childrens": [],
                    "createDate": "1973-11-26 08:52",
                    "level": 2,
                    "toUser": {
                        "nickname": "李四",
                        "avatar": "http://localhost:8080/static/img/logo.b3a48c0.png",
                        "id": 1
                    }
                }
            ],
            "createDate": "1973-11-27 09:53",
            "level": 1,
            "toUser": null
        }
    ]
}
~~~

数据表：

```
import lombok.Data;

@Data
public class Comment {

    private Long id;

    private String content;

    private Long createDate;

    private Long articleId;//文章id

    private Long authorId;//文章作者id

    private Long parentId;//父评论id

    private Long toUid;//评论谁

    private Integer level;//1级评论还是2级评论
}
```

Controller

```
@RestController
@RequestMapping("comments")
public class CommentsController {

    @Autowired
    private CommentsService commentsService;

    @GetMapping("article/{id}")
    public Result comments(@PathVariable("id") Long articleId){

        return commentsService.commentsByArticleId(articleId);

    }
}
```

service

```
public interface CommentsService {
    /**
     * 根据文章id查看所有评论
     * @param id
     * @return
     */
    Result commentsByArticleId(Long id);
}
```



```
@Service
public class CommentsServiceImpl implements CommentsService {

    @Autowired
    private CommentMapper commentMapper;

    @Autowired
    private SysUserService sysUserService;

    @Override
    public Result commentsByArticleId(Long id) {
        //1.根据id查询所有的评论
        //2.根据作者id查询作者信息
        //3.如果level==1查询有没有子评论
        //4.如果有 根据parent_id去查子评论

        LambdaQueryWrapper<Comment> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(Comment::getArticleId,id);
        queryWrapper.eq(Comment::getLevel,1);

        List<Comment> comments = commentMapper.selectList(queryWrapper);
        List<CommentVo> ans =  copyList(comments);//2.3.4步 都在这里
        return Result.success(ans);
    }


    private List<CommentVo> copyList(List<Comment> comments) {
        List<CommentVo> commentVos = new ArrayList<>();
        for (Comment comment : comments) {
            commentVos.add(copy(comment));
        }
        return commentVos;
    }

    /**
     *         //2.根据作者id查询作者信息
     *         //3.如果level==1查询有没有子评论
     *         //4.如果有 根据parent_id去查子评论
     * @param comment
     * @return
     */
    private CommentVo copy(Comment comment) {
        CommentVo commentVo = new CommentVo();
        BeanUtils.copyProperties(comment,commentVo);
        //时间格式化
        commentVo.setCreateDate(new DateTime(comment.getCreateDate()).toString("yyyy-MM-dd HH:mm"));
        Long authorId = comment.getAuthorId();

        //设置作者
        UserVo userVo =  sysUserService.findUserVoById(authorId);
        commentVo.setAuthor(userVo);

        //评论的评论
        List<CommentVo> commentVoList = findCommentsByParentId(comment.getId());//查询所有的子评论
        commentVo.setChildrens(commentVoList);

        if(comment.getLevel()>1){//是子评论，则将子评论的Vo封装
            Long toUid = comment.getToUid();
            UserVo toUserVo = sysUserService.findUserVoById(toUid);

            commentVo.setToUser(toUserVo);
        }
        return commentVo;

    }

    /**
     * 根据一个父评论id查询所有的子评论
     * @param id
     * @return
     */
    private List<CommentVo> findCommentsByParentId(Long id) {
        LambdaQueryWrapper<Comment> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(Comment::getParentId,id);
        queryWrapper.eq(Comment::getLevel,2);
        List<Comment> comments = commentMapper.selectList(queryWrapper);
        return copyList(comments);

    }
}
```

返回的数据

```
@Data
public class CommentVo  {

    private Long id;

    private UserVo author;

    private String content;

    private List<CommentVo> childrens;

    private String createDate;

    private Integer level;

    private UserVo toUser;
}

```

```
@Data
public class UserVo {

    private String nickname;

    private String avatar;

    private Long id;
}
	
```

在SysUserService中提供 查询用户信息的服务：

```
UserVo findUserVoById(Long authorId);
```

```
@Override
public UserVo findUserVoById(Long authorId) {
    SysUser sysUser = sysUserMapper.selectById(authorId);
    if(sysUser==null){//防止测试报错
        sysUser.setId(1L);
        sysUser.setNickname("测试的NickName");
    }
    UserVo userVo = new UserVo();
    BeanUtils.copyProperties(sysUser,userVo);
    return userVo;
}
```



### 评论

接口url：/comments/create/change

请求方式：POST

请求参数：

| 参数名称  | 参数类型 | 说明           |
| --------- | -------- | -------------- |
| articleId | long     | 文章id         |
| content   | string   | 评论内容       |
| parent    | long     | 父评论id       |
| toUserId  | long     | 被评论的用户id |

返回数据：

~~~json
{
    "success": true,
    "code": 200,
    "msg": "success",
    "data": null
}
~~~

加入到拦截器

```
@Override
    public void addInterceptors(InterceptorRegistry registry) {
        //拦截test接口，后续实际遇到需要拦截的接口时，在配置为真正的拦截接口
        registry.addInterceptor(loginInterceptor)
                .addPathPatterns("/test").addPathPatterns("/comments/create/change");
    }
```

参数

```
import lombok.Data;

@Data
public class CommentParam {

    private Long articleId;

    private String content;

    private Long parent;

    private Long toUserId;
}
```

```
/**
 * 评论
 * @param commentParam
 * @return
 */
@PostMapping("/create/change")
public Result createComment(@RequestBody CommentParam commentParam){
    return commentsService.addComment(commentParam);
}
```

> BUG
>
> 添加一条评论后，数据库中会存入错误的ToUserId,导致查看文章并显示评论的功能中报错
>
> ![image-20220315162834503](C:\Users\张渭\AppData\Roaming\Typora\typora-user-images\image-20220315162834503.png)
>
> 真实的ToUserId应该是1404448588146192387（root用户的id）

### 写文章

写文章需要 三个接口：

1. 获取所有文章类别

2. 获取所有标签
3. 发布文章

#### 1. 获取所有文章类别

接口url：/categorys

请求方式：GET

请求参数：

| 参数名称 | 参数类型 | 说明 |
| -------- | -------- | ---- |
|          |          |      |
|          |          |      |
|          |          |      |

返回数据：

~~~json
{
    "success":true,
 	"code":200,
    "msg":"success",
    "data":
    [
        {"id":1,"avatar":"/category/front.png","categoryName":"前端"},	
        {"id":2,"avatar":"/category/back.png","categoryName":"后端"},
        {"id":3,"avatar":"/category/lift.jpg","categoryName":"生活"},
        {"id":4,"avatar":"/category/database.png","categoryName":"数据库"},
        {"id":5,"avatar":"/category/language.png","categoryName":"编程语言"}
    ]
}
~~~

Controller

```
@RestController
@RequestMapping("/categorys")
public class CategoryController {
    @Autowired
    private CategoryService categoryService;

    @RequestMapping
    public Result getCategorys(){
        return  categoryService.findAll();
    }
}
```

service

```
Result findAll();
```

```
    @Override
    public Result findAll() {
        LambdaQueryWrapper<Category> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.select(Category::getId,Category::getCategoryName);//只要这两个字段
        List<Category> categories = categoryMapper.selectList(queryWrapper);//查询所有

        return Result.success(copyList(categories));
    }
    private List<CategoryVo> copyList(List<Category> categories) {
        ArrayList<CategoryVo> categoryVos = new ArrayList<>();
        for (Category category : categories) {
            categoryVos.add(copy(category));
        }
        return categoryVos;
    }

    private CategoryVo copy(Category category) {
        CategoryVo categoryVo = new CategoryVo();
        BeanUtils.copyProperties(category,categoryVo);
        return categoryVo;
    }
```

#### 2.所有文章标签

接口url：/tags

请求方式：GET

请求参数：

| 参数名称 | 参数类型 | 说明 |
| -------- | -------- | ---- |
|          |          |      |
|          |          |      |
|          |          |      |

返回数据：

~~~json
{
    "success": true,
    "code": 200,
    "msg": "success",
    "data": [
        {
            "id": 5,
            "tagName": "springboot"
        },
        {
            "id": 6,
            "tagName": "spring"
        },
        {
            "id": 7,
            "tagName": "springmvc"
        },
        {
            "id": 8,
            "tagName": "11"
        }
    ]
}
~~~

TagsController

```
@GetMapping
public Result findAll(){
    return tagService.findAll();
}
```

TagService

```
Result findAll();
```

```
@Override
public Result findAll() {
    List<Tag> tagList = tagMapper.selectList(new QueryWrapper<>());
    return Result.success(copyList(tagList));
}
```

#### 3.发布文章

接口url：/articles/publish

请求方式：POST

请求参数：

| 参数名称 | 参数类型                                                    | 说明               |
| -------- | ----------------------------------------------------------- | ------------------ |
| title    | string                                                      | 文章标题           |
| id       | long                                                        | 文章id（编辑有值） |
| body     | object（{content: "ww", contentHtml: "<p>ww</p>↵"}）        | 文章内容           |
| category | {id: 2, avatar: "/category/back.png", categoryName: "后端"} | 文章类别           |
| summary  | string                                                      | 文章概述           |
| tags     | [{id: 5}, {id: 6}]                                          | 文章标签           |

返回数据：

~~~json
{
    "success": true,
    "code": 200,
    "msg": "success",
    "data": {"id":12232323}
}
~~~

controller

```
/**
 * 发布文章
 * @return
 */
@PostMapping("/publish")
public Result publish(@RequestBody ArticleParam articleParam){
    return articleService.publish(articleParam);
}
```

service

```
Result publish(ArticleParam articleParam);
```

```java
@Override
public Result publish(ArticleParam articleParam) {
    //需要去拦截才能使用ThreadLocal，否则空指针异常
    SysUser sysUser = UserThreadLocal.get();

    Article article = new Article();
    article.setTitle(articleParam.getTitle());
    article.setSummary(articleParam.getSummary());
    article.setAuthorId(sysUser.getId());
    article.setCategoryId(articleParam.getCategory().getId());
    article.setCommentCounts(0);
    article.setViewCounts(0);
    article.setWeight(Article.Article_Common);//权重非置顶
    article.setCreateDate(System.currentTimeMillis());
    articleMapper.insert(article);//插入后，article会有一个Id？？？

    //tag
    List<TagVo> tags = articleParam.getTags();
    ArticleTag articleTag ;
    if(tags!=null)
        for (TagVo tag : tags) {
            articleTag = new ArticleTag();
            articleTag.setTagId(tag.getId());
            articleTag.setArticleId(article.getId());
            articleTagMapper.insert(articleTag);
        }

    //文章体
    ArticleBodyParam articleBodyParam = articleParam.getBody();
    ArticleBody articleBody = new ArticleBody();
    articleBody.setContent(articleBodyParam.getContent());
    articleBody.setContentHtml(articleBodyParam.getContentHtml());
    articleBody.setArticleId(article.getId());//因为article已经insert了
    articleBodyMapper.insert(articleBody);//先插入
    Long bodyId = articleBody.getId();//id就生成了
    article.setBodyId(bodyId);


    articleMapper.updateById(article);//更新article

    return Result.success(article);
}
```

这个逻辑要加事务，放在方法上或类上

```
@Transactional
```

### AOP日志

```
import java.lang.annotation.*;

/**
 * 日志注解
 */
@Target(ElementType.METHOD)
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface LogAnnotation {

    String module() default "";

    String operation() default "";
}
```

```java
@Aspect
@Component
@Slf4j
public class LogAspect {
    @Pointcut("@annotation(top.ambtwill.blog.common.aop.LogAnnotation)")//切入点标记为注解
    public void logPointCut(){}

    @Around("logPointCut()")//标记切入点
    public Object around(ProceedingJoinPoint point) throws Throwable {
        long beginTime = System.currentTimeMillis();
        //执行方法
        Object result = point.proceed();
        //执行时长(毫秒)
        long time = System.currentTimeMillis() - beginTime;
        //保存日志
        recordLog(point, time);
        return result;
    }
    private void recordLog(ProceedingJoinPoint joinPoint, long time) {
        MethodSignature signature = (MethodSignature) joinPoint.getSignature();
        Method method = signature.getMethod();
        LogAnnotation logAnnotation = method.getAnnotation(LogAnnotation.class);
        log.info("=====================log start================================");
        log.info("module:{}",logAnnotation.module());
        log.info("operation:{}",logAnnotation.operation());

        //请求的方法名
        String className = joinPoint.getTarget().getClass().getName();
        String methodName = signature.getName();
        log.info("request method:{}",className + "." + methodName + "()");

//        //请求的参数
        Object[] args = joinPoint.getArgs();
        String params = JSON.toJSONString(args[0]);
        log.info("params:{}",params);

        //获取request 设置IP地址
        // HttpServletRequest request = HttpContextUtils.getHttpServletRequest();
        // log.info("ip:{}", IpUtils.getIpAddr(request));


        log.info("excute time : {} ms",time);
        log.info("=====================log end================================");
    }

}
```

> HttpContextUtils、IpUtils这两个工具类没有写，去网上找

### 文章图片上传

存储图片不存在应用服务器上，存放在图片服务器上，不让它对我们应用服务器造成影响

接口url：/upload

请求方式：POST

请求参数：

| 参数名称 | 参数类型 | 说明           |
| -------- | -------- | -------------- |
| image    | file     | 上传的文件名称 |
|          |          |                |
|          |          |                |

返回数据：

~~~json
{
    "success":true,
 	"code":200,
    "msg":"success",
    "data":"https://static.mszlu.com/aa.png"
}
~~~

七牛云的依赖

~~~xml
<dependency>
  <groupId>com.qiniu</groupId>
  <artifactId>qiniu-java-sdk</artifactId>
  <version>[7.7.0, 7.7.99]</version>
</dependency>
~~~

Controller

```java
@RestController
@RequestMapping("/upload")
public class UploadController {
    @Autowired
    private QiniuUtils qiniuUtils;

    @PostMapping
    public Result upload(@RequestParam("image") MultipartFile file){
        //原始文件名称a.png
        String originalFilename = file.getOriginalFilename();

        //唯一文件名称 123png
        String fileName = UUID.randomUUID().toString() + "." + StringUtils.substringAfterLast(file.getOriginalFilename(), ".");

        boolean upload = qiniuUtils.upload(file, fileName);
        if(upload){
            return Result.success(QiniuUtils.url+"/"+ fileName);
        }
        return Result.fail(20001,"上传失败");
    }
}
```

application.properties中加入，上传文件的配置

```
# 上传文件总的最大值
spring.servlet.multipart.max-request-size=20MB
# 单个文件的最大值
spring.servlet.multipart.max-file-size=2MB
```

QiniuUtils

```java
@Component
public class QiniuUtils {

    public static  final String url = "http://r8tw35bk8.hd-bkt.clouddn.com";//临时的

    // @Value("${qiniu.accessKey}")
    @Value("mzPDkCjIjcfrYA7Acd6hLkZ-sMSznZ7nXEWCwDBt")
    private  String accessKey;

    // @Value("${qiniu.accessSecretKey}")
    @Value("uWIxjCJGaa9U7frxzDLvMU-eTA25xb0uLhut0z1f")
    private  String accessSecretKey;

    public  boolean upload(MultipartFile file,String fileName){

        //构造一个带指定 Region 对象的配置类
        Configuration cfg = new Configuration(Region.huadong());//???
        //...其他参数参考类注释
        UploadManager uploadManager = new UploadManager(cfg);
        //...生成上传凭证，然后准备上传
        String bucket = "ambtblogpic";//空间名称
        //默认不指定key的情况下，以文件内容的hash值作为文件名
        try {
            byte[] uploadBytes = file.getBytes();
            Auth auth = Auth.create(accessKey, accessSecretKey);
            String upToken = auth.uploadToken(bucket);
                Response response = uploadManager.put(uploadBytes, fileName, upToken);
                //解析上传成功的结果
                DefaultPutRet putRet = JSON.parseObject(response.bodyString(), DefaultPutRet.class);
                return true;
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        return false;
    }
}
```

七牛云相关的步骤：

https://portal.qiniu.com/home

进入七牛云控制台，新建存储空间，名为ambtblogpic

![image.png](http://r8tw35bk8.hd-bkt.clouddn.com/26b848c3-2f25-4f6c-9a7a-f6e39951bd1f.png)

将存储空间名放到QiniuUtil的变量bucket中

![image.png](http://r8tw35bk8.hd-bkt.clouddn.com/4a8dcc03-a4cf-4fee-8b36-e1d220c77af4.png)

创建存储空间后生成了一个临时的域名（有效期30天）

![image.png](http://r8tw35bk8.hd-bkt.clouddn.com/ccc63449-e4dc-4363-b836-f6c090c26741.png)

放到QiniuUtil的变量URL中

![image.png](http://r8tw35bk8.hd-bkt.clouddn.com/5a90e033-5d51-41a9-9555-3e4b4972ab4c.png)

进入密钥管理

![image.png](http://r8tw35bk8.hd-bkt.clouddn.com/dfc04d8d-22f6-4dd7-b9a3-755d0f8c0266.png)

将下面两个参数，放到QiniuUtil中

![image.png](http://r8tw35bk8.hd-bkt.clouddn.com/9677d745-bf41-4a42-8ee3-f7a12860ac76.png)

其中，AK对应accessKey,SK对应accessSecretKey
![image.png](http://r8tw35bk8.hd-bkt.clouddn.com/a913e922-612b-48e2-aa14-bbadb6a92a8f.png)其实可以存放在配置文件中，将该类加入到容器（注解组件）

>  七牛云的一切使用参考七牛云文档：https://developer.qiniu.com/kodo/1239/java#server-upload



#### 注解概念混淆

- @RequestParam:将请求参数绑定到控制器的方法参数上
- @PathVariable:将URL中的请求参数绑定到控制器的方法参数上
- @RequestBody:接受请求体中的数据
- @Param:dao层使用，作用是给参数命名,参数命名后就能根据名字得到参数值,正确的将参数传入sql语句中



### 导航-文章分类

#### 查询所有的文章分类

接口url：/categorys/detail

请求方式：GET

请求参数：

| 参数名称 | 参数类型 | 说明 |
| -------- | -------- | ---- |
|          |          |      |
|          |          |      |
|          |          |      |

返回数据：

~~~json
{
    "success": true, 
    "code": 200, 
    "msg": "success", 
    "data": [
        {
            "id": 1, 
            "avatar": "/static/category/front.png", 
            "categoryName": "前端", 
            "description": "前端是什么，大前端"
        }, 
        {
            "id": 2, 
            "avatar": "/static/category/back.png", 
            "categoryName": "后端", 
            "description": "后端最牛叉"
        }, 
        {
            "id": 3, 
            "avatar": "/static/category/lift.jpg", 
            "categoryName": "生活", 
            "description": "生活趣事"
        }, 
        {
            "id": 4, 
            "avatar": "/static/category/database.png", 
            "categoryName": "数据库", 
            "description": "没数据库，啥也不管用"
        }, 
        {
            "id": 5, 
            "avatar": "/static/category/language.png", 
            "categoryName": "编程语言", 
            "description": "好多语言，该学哪个？"
        }
    ]
}

~~~

```
@GetMapping("/detail")
public Result getCategorysDetail(){
    return categoryService.findAllDetails();
}
```

```
Result findAllDetails();
```

```
@Override
public Result findAllDetails() {
    List<Category> categories = categoryMapper.selectList(new QueryWrapper<>());
    return Result.success(categories);
}
```

#### 查询所有的标签

接口url：/tags/detail

请求方式：GET

请求参数：

| 参数名称 | 参数类型 | 说明 |
| -------- | -------- | ---- |
|          |          |      |
|          |          |      |
|          |          |      |

返回数据：

~~~json
{
    "success": true, 
    "code": 200, 
    "msg": "success", 
    "data": [
        {
            "id": 5, 
            "tagName": "springboot", 
            "avatar": "/static/tag/java.png"
        }, 
        {
            "id": 6, 
            "tagName": "spring", 
            "avatar": "/static/tag/java.png"
        }, 
        {
            "id": 7, 
            "tagName": "springmvc", 
            "avatar": "/static/tag/java.png"
        }, 
        {
            "id": 8, 
            "tagName": "11", 
            "avatar": "/static/tag/css.png"
        }
    ]
}
~~~

```
@GetMapping("/detail")
public Result findAllDetail(){
    return tagService.findAllDetail();
}
```

```
Result findAllDetail();
```

```
@Override
public Result findAllDetail() {
    List<Tag> tagList = tagMapper.selectList(new QueryWrapper<>());
    return Result.success(tagList);
}
```

### 查询某分类下的文章列表

接口url：/categorys/detail/{id}

请求方式：GET

请求参数：

| 参数名称 | 参数类型 | 说明     |
| -------- | -------- | -------- |
| id       | 分类id   | 路径参数 |
|          |          |          |
|          |          |          |

返回数据：

~~~json
{
    "success": true, 
    "code": 200, 
    "msg": "success", 
    "data": 
        {
            "id": 1, 
            "avatar": "/static/category/front.png", 
            "categoryName": "前端", 
            "description": "前端是什么，大前端"
        }
}

~~~

根据id查看分类详情：

```
@GetMapping("/detail/{id}")
public Result getCategorysDetailById(@PathVariable Long id){
    return categoryService.findCategoryDetailById(id);
}
```

 ```
Result findCategoryDetailById(Long categoryId); 	
 ```

```
@Override
public Result findCategoryDetailById(Long categoryId) {
    Category category = categoryMapper.selectById(categoryId);
    return Result.success(category);
}
```

根据分类id查看该分类下的所有文章：（需要重构ArticleServiceImpl的listArticle方法，添加如下）

```
// 已弃用 最新的listArticle方法中自定义SQL语句在了ArticleMapper.xml中   
//	   if(pageParams.getCategoryId()!=null){//扩展了功能，P30
//         queryWrapper.eq(Article::getCategoryId,pageParams.getCategoryId());
//         //相当于加上 and article_id = #{articleId};
//     }
```

```
import lombok.Data;

@Data
public class PageParams {

    private int page = 1;

    private int pageSize = 10;

    private Long categoryId;

    private Long tagId;
}
```

### 查询某标签下文章列表

接口url：/tags/detail/{id}

请求方式：GET

请求参数：

| 参数名称 | 参数类型 | 说明     |
| -------- | -------- | -------- |
| id       | 标签id   | 路径参数 |
|          |          |          |
|          |          |          |

返回数据：

~~~json
{
    "success": true, 
    "code": 200, 
    "msg": "success", 
    "data": 
        {
            "id": 5, 
            "tagName": "springboot", 
            "avatar": "/static/tag/java.png"
        }
}

~~~

根据具体的tagId对应的Tag的详情：

```
@GetMapping("/detail/{id}")
public Result findDetailById(@PathVariable Long id){
    return tagService.findDetailById(id);
}
```

```
Result findDetailById(Long id);
```

```
@Override
public Result findDetailById(Long id) {
    Tag tag = tagMapper.selectById(id);
    return Result.success(tag);
}
```

根据具体的tagId查询该标签下的所有文章：（需要重构ArticleServiceImpl的listArticle方法，添加如下）

```
//已弃用 最新的listArticle方法中自定义SQL语句在了ArticleMapper.xml中 
//if(pageParams.getTagId() != null){
//         // select * from article where id in (select articleId from ArticleTag where tag_id==#{TagId})
//         ArrayList<Long> articleIdList = new ArrayList<>();
//         LambdaQueryWrapper<ArticleTag> queryWrapper2 = new LambdaQueryWrapper<>();
//         queryWrapper2.eq(ArticleTag::getTagId,pageParams.getTagId());
//         queryWrapper2.select(ArticleTag::getArticleId);
//         List<ArticleTag> articleTags = articleTagMapper.selectList(queryWrapper2);
//         for (ArticleTag articleTag : articleTags) {
//             articleIdList.add(articleTag.getArticleId());
//         }
//         if(articleIdList.size()>0){
//             queryWrapper.in(Article::getId,articleIdList);
//         }
//     }
```

### 归档文章列表

接口url：/articles

请求方式：POST

请求参数：

| 参数名称 | 参数类型 | 说明 |
| -------- | -------- | ---- |
| year     | string   | 年   |
| month    | string   | 月   |
|          |          |      |

返回数据：

~~~json
{
    "success": true, 
    "code": 200, 
    "msg": "success", 
    "data": [文章列表，数据同之前的文章列表接口]
        
}
~~~

```
@Data
public class PageParams {

    private int page=1;

    private int pageSize=10;

    private Long categoryId;

    private Long tagId;

    private String year;

    private String month;

    // public String getMonth(){
    //     if (this.month != null && this.month.length() == 1){
    //         return "0"+this.month;
    //     }
    //     return this.month;
    // }
}
```

使用自定义sql 实现文章列表：（因为mybatis-plus不支持FROM_UNIXTIME）

重构ArticleServiceImpl的listArticle方法

```
@Override
public Result listArticle(PageParams pageParams) {
    Page<Article> page = new Page<>(pageParams.getPage(), pageParams.getPageSize());
    IPage<Article> articleIPage = articleMapper.listArticle(
            page,
            pageParams.getCategoryId(),
            pageParams.getTagId(),
            pageParams.getYear(),
            pageParams.getMonth()
    );
    List<Article> records = articleIPage.getRecords();
    return Result.success(copyList(records,true,true));

}
```

articleMapper接口中的listArticle方法

```
IPage<Article> listArticle(Page<Article> page,
                           Long categoryId,
                           Long tagId,
                           String year,
                           String month
                           );
```

articleMapper.xml文件中的sql语句

```sql
<select id="listArticle" resultType="top.ambtwill.blog.dao.pojo.Article">
    select * from ms_article
    <where>
        1=1
        <if test="categoryId != null">
            and category_id=#{categoryId}
        </if>
        <if test="tagId != null">
            and id in (select article_id from ms_article_tag where tag_id = #{tagId})
        </if>
        <if test="month != null and month.length>0 and year != null and year.length>0">
            and year(FROM_UNIXTIME(create_date/1000)) = #{year}
            and month(FROM_UNIXTIME(create_date/1000)) = #{month}
        </if>
    </where>
    order by weight,create_date desc
</select>
```

### 统一缓存处理（优化）

> 内存的访问速度 远远大于 磁盘的访问速度 （1000倍起）

切入点注解

```
import java.lang.annotation.*;

@Target({ElementType.METHOD})
@Retention(RetentionPolicy.RUNTIME)
@Documented
public @interface Cache {

    long expire() default 1 * 60 * 1000;//过期时间

    String name() default "";//缓存标识

}
```

自定义切面类(使用环绕增强，即在方法执行前后增强)

```java
//aop定义一个切面，切面定义了切入点、通知
@Aspect
@Component
@Slf4j
public class CacheAspect {
    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    @Pointcut("@annotation(top.ambtwill.blog.common.cache.Cache)")
    public void pt(){}

    @Around("pt()")
    public Object around(ProceedingJoinPoint pjp){
        try {
            Signature signature = pjp.getSignature();
            //类名
            String className = pjp.getTarget().getClass().getSimpleName();
            //调用的方法名
            String methodName = signature.getName();


            Class[] parameterTypes = new Class[pjp.getArgs().length];
            Object[] args = pjp.getArgs();
            //参数
            String params = "";
            for(int i=0; i<args.length; i++) {
                if(args[i] != null) {
                    params += JSON.toJSONString(args[i]);
                    parameterTypes[i] = args[i].getClass();
                }else {
                    parameterTypes[i] = null;
                }
            }
            if (StringUtils.isNotEmpty(params)) {
                //加密 以防出现key过长以及字符转义获取不到的情况
                params = DigestUtils.md5Hex(params);
            }
            Method method = pjp.getSignature().getDeclaringType().getMethod(methodName, parameterTypes);
            //获取Cache注解
            Cache annotation = method.getAnnotation(Cache.class);
            //缓存过期时间
            long expire = annotation.expire();
            //缓存名称
            String name = annotation.name();
            //先从redis获取
            String redisKey = name + "::" + className+"::"+methodName+"::"+params;
            String redisValue = redisTemplate.opsForValue().get(redisKey);
            if (StringUtils.isNotEmpty(redisValue)){//缓存中存在，就从缓存中拿
                log.info("走了缓存~~~,{},{}",className,methodName);
                return JSON.parseObject(redisValue, Result.class);
            }
            Object proceed = pjp.proceed();//否则，调用方法，再放到缓存中
            redisTemplate.opsForValue().set(redisKey,JSON.toJSONString(proceed), Duration.ofMillis(expire));
            log.info("存入缓存~~~ {},{}",className,methodName);
            return proceed;
        } catch (Throwable throwable) {
            throwable.printStackTrace();
        }
        return Result.fail(-999,"系统错误");
    }
}
```

使用方式：在方法上加上注解

```
@Cache(expire = 5*60*1000,name = "listArticle")
```

![image-20220319165130931](C:\Users\张渭\AppData\Roaming\Typora\typora-user-images\image-20220319165130931.png)

> expire:到期时间

加上缓存后，控制台输出如下：

![image-20220319164802788](C:\Users\张渭\AppData\Roaming\Typora\typora-user-images\image-20220319164802788.png)

运行效率大幅增加，但是会造成缓存一致性问题，后面介绍

### 缓存精度问题

在上一小节中，查询操作加入到了缓存，但是又出现了id精度问题，id到前端丢失了精度

![image-20220319183610566](C:\Users\张渭\AppData\Roaming\Typora\typora-user-images\image-20220319183610566.png)

解决方案：

1. 将所有的Id全部转换成String类型（视频中）

   以后雪花算法的id都设置成字符串类型，就可以省很多事

   

2. 不使用雪花算法生成ID的策略

## 权限管理后台（blog-admin）

### 搭建项目

```
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0"
         xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
         xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd">
    <parent>
        <artifactId>blog-parent</artifactId>
        <groupId>top.ambtwill</groupId>
        <version>1.0-SNAPSHOT</version>
    </parent>
    <modelVersion>4.0.0</modelVersion>

    <artifactId>blog-admin</artifactId>

    <dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter</artifactId>
            <!-- 排除 默认使用的logback  -->
            <exclusions>
                <exclusion>
                    <groupId>org.springframework.boot</groupId>
                    <artifactId>spring-boot-starter-logging</artifactId>
                </exclusion>
            </exclusions>
        </dependency>


        <!-- log4j2 -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-log4j2</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-aop</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-mail</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>

        <dependency>
            <groupId>com.alibaba</groupId>
            <artifactId>fastjson</artifactId>
            <version>1.2.76</version>
        </dependency>

        <dependency>
            <groupId>mysql</groupId>
            <artifactId>mysql-connector-java</artifactId>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-configuration-processor</artifactId>
            <optional>true</optional>
        </dependency>

        <dependency>
            <groupId>org.apache.commons</groupId>
            <artifactId>commons-lang3</artifactId>
        </dependency>

        <dependency>
            <groupId>commons-collections</groupId>
            <artifactId>commons-collections</artifactId>
            <version>3.2.2</version>
        </dependency>
        <dependency>
            <groupId>commons-codec</groupId>
            <artifactId>commons-codec</artifactId>
        </dependency>

        <dependency>
            <groupId>com.baomidou</groupId>
            <artifactId>mybatis-plus-boot-starter</artifactId>
            <version>3.4.3</version>
        </dependency>

        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <version>1.18.22</version>
        </dependency>

        <dependency>
            <groupId>joda-time</groupId>
            <artifactId>joda-time</artifactId>
            <version>2.10.10</version>
        </dependency>

        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>

    </dependencies>

</project>
```

application.properties

```
server.port=8889
spring.application.name=my_blog_admin

#数据库的配置
# datasource
spring.datasource.url=jdbc:mysql://localhost:3306/blog?useUnicode=true&characterEncoding=UTF-8&serverTimeZone=UTC
spring.datasource.username=root
spring.datasource.password=root
spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver

#mybatis-plus
mybatis-plus.configuration.log-impl=org.apache.ibatis.logging.stdout.StdOutImpl
mybatis-plus.global-config.db-config.table-prefix=ms_
```

mybatis-plus配置：

```
import com.baomidou.mybatisplus.extension.plugins.MybatisPlusInterceptor;
import com.baomidou.mybatisplus.extension.plugins.inner.PaginationInnerInterceptor;
import org.mybatis.spring.annotation.MapperScan;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
@MapperScan("top.ambtwill.blog.admin.dao")
public class MybatisPlusConfig {

    //分页插件
    @Bean
    public MybatisPlusInterceptor mybatisPlusInterceptor(){
        MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor();
        interceptor.addInnerInterceptor(new PaginationInnerInterceptor());
        return interceptor;
    }
}
```

启动类

```
@SpringBootApplication
public class AdminApp {
    public static void main(String[] args) {
        SpringApplication.run(AdminApp.class,args);
    }
}
```

导入前端工程

静态资源在blog-admin模块中resources/static中

数据表(3张)

```
`ms_admin` 
`ms_permission`
`ms_admin_permission`
```

### 权限管理

AdminController

```
@RestController
@RequestMapping("/admin")
public class AdminController {
    @Autowired
    private PermissionService permissionService;

    @PostMapping("/permission/permissionList")
    public Result listPermission(@RequestBody PageParam pageParam){
        return permissionService.listPermission(pageParam);
    }

    @PostMapping("permission/add")
    public Result add(@RequestBody Permission permission){
        return permissionService.add(permission);
    }

    @PostMapping("permission/update")
    public Result update(@RequestBody Permission permission){
        return permissionService.update(permission);
    }

    @GetMapping("permission/delete/{id}")
    public Result delete(@PathVariable("id") Long id){
        return permissionService.delete(id);
    }

}
```

PageParam

```
@Data
public class PageParam {
    private Integer currentPage;

    private Integer pageSize;

    private String queryString;
}
```

Permission

```
@Data
public class Permission {

    @TableId(type = IdType.AUTO)
    private Long id;

    private String name;

    private String path;

    private String description;
}
```

PermissionService

```
@Service
public class PermissionService {
    @Autowired
    private PermissionMapper permissionMapper;

    /**
     * 要的数据：表的所有字段
     * 分页
     * @param pageParam
     * @return
     */
    public Result listPermission(PageParam pageParam) {
        Page<Permission> page = new Page<>(pageParam.getCurrentPage(), pageParam.getPageSize());
        LambdaQueryWrapper<Permission> queryWrapper = new LambdaQueryWrapper<>();
        if(StringUtils.isNotBlank(pageParam.getQueryString())){
            queryWrapper.eq(Permission::getName,pageParam.getQueryString());
        }
        Page<Permission> permissionPage = permissionMapper.selectPage(page, new LambdaQueryWrapper<>());
        PageResult<Permission> pageResult = new PageResult<>();
        pageResult.setList(permissionPage.getRecords());
        pageResult.setTotal(permissionPage.getTotal());
        return Result.success(pageResult);
    }

    public Result add(Permission permission) {
        permissionMapper.insert(permission);
        return Result.success(null);

    }

    public Result update(Permission permission) {
        permissionMapper.updateById(permission);
        return Result.success(null);
    }

    public Result delete(Long id) {

        permissionMapper.deleteById(id);
        return Result.success(null);
    }
}
```

PermissionMapper

```
@Mapper
@Repository
public interface PermissionMapper  extends BaseMapper<Permission> {
    @Select("select * from ms_permission where id in (select permission_id from ms_admin_permission where admin_id=#{adminId})")
    List<Permission> findPermissionsByAdminId(Long adminId);
}
```

Result

```
@Data
@AllArgsConstructor
public class Result {
    private boolean success;

    private int code;

    private String msg;

    private Object data;

    public static Result success(Object data){
        return new Result(true,200,"success",data);
    }

    public static Result fail(int code,String msg){
        return new Result(false,code,msg,null);
    }
}
```

PageResult

```
@Data
public class PageResult<T> {

    private List<T> list;

    private Long total;
}
```

### Security集成

依赖

```
 		<dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
```

> 访问http://localhost:8889/pages/main.html会自动跳转到登录界面，原因是因为有SpringSecurity依赖,
>
> ![image-20220318153245018](C:\Users\张渭\AppData\Roaming\Typora\typora-user-images\image-20220318153245018.png)
>
> 删除该依赖后，就能够成功进入，如下图
>
> ![image-20220318153440858](C:\Users\张渭\AppData\Roaming\Typora\typora-user-images\image-20220318153440858.png)

#### **配置**

```
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;

import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;


@Configuration
public class SecurityConfig extends WebSecurityConfigurerAdapter {

    @Bean
    public BCryptPasswordEncoder bCryptPasswordEncoder(){//bCrypt为加密策略
        return new BCryptPasswordEncoder();
    }

    public static void main(String[] args) {//生成密码
        //加密策略 MD5 不安全 彩虹表  MD5 加盐
        // String password = new BCryptPasswordEncoder().encode("root");
        String password = new BCryptPasswordEncoder().encode("123");
        System.out.println(password);
    }
    @Override
    public void configure(WebSecurity web) throws Exception {
        super.configure(web);
    }
    @Override
    protected void configure(HttpSecurity http) throws Exception {

        http.authorizeRequests() //开启登录认证
//              .antMatchers("/user/findAll").hasRole("admin") //访问接口需要admin的角色
                .antMatchers("/css/**").permitAll()
                .antMatchers("/img/**").permitAll()
                .antMatchers("/js/**").permitAll()
                .antMatchers("/plugins/**").permitAll()
                .antMatchers("/admin/**").access("@authService.auth(request,authentication)") //自定义service 来去实现实时的权限认证
                .antMatchers("/pages/**").authenticated()
                .and().formLogin()
                .loginPage("/login.html") //自定义的登录页面
                .loginProcessingUrl("/login") //登录处理接口
                .usernameParameter("username") //定义登录时的用户名的key 默认为username
                .passwordParameter("password") //定义登录时的密码key，默认是password
                .defaultSuccessUrl("/pages/main.html")
                .failureUrl("/login.html")
                .permitAll() //通过 不拦截，更加前面配的路径决定，这是指和登录表单相关的接口 都通过
                .and().logout() //退出登录配置
                .logoutUrl("/logout") //退出登录接口
                .logoutSuccessUrl("/login.html")
                .permitAll() //退出登录的接口放行
                .and()
                .httpBasic()
                .and()
                .csrf().disable() //csrf关闭 如果自定义登录 需要关闭
                .headers().frameOptions().sameOrigin();
    }
}
```

#### 登录认证

SecurityUserService

```
@Component
public class SecurityUserService implements UserDetailsService {
    @Autowired
    private AdminService adminService;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        //登录的时候会把username传递过来
        //查询admin表，存在就将密码告诉SpringSecurity
        //不存在返回null
        Admin admin = adminService.findAdminByUsername(username);
        if(admin==null){
            //登录失败
            return null;
        }
        UserDetails userDetails = new User(username, admin.getPassword(), new ArrayList<>());
        //剩下的认证由框架帮我们完成
        return userDetails;
    }
}
```

Admin

```
import com.baomidou.mybatisplus.annotation.IdType;
import com.baomidou.mybatisplus.annotation.TableId;
import lombok.Data;

@Data
public class Admin {

    @TableId(type = IdType.AUTO)
    private Long id;

    private String username;

    private String password;
}
```

AdminService

```
@Service
public class AdminService {

    @Autowired
    private AdminMapper adminMapper;

    @Autowired
    private PermissionMapper permissionMapper;

    public Admin findAdminByUsername(String username){
        LambdaQueryWrapper<Admin> queryWrapper = new LambdaQueryWrapper<>();
        queryWrapper.eq(Admin::getUsername,username);
        Admin admin = adminMapper.selectOne(queryWrapper);
        return admin;
    }

    public List<Permission> findPermissionsByAdminId(Long adminId){
        return permissionMapper.findPermissionsByAdminId(adminId);
    }
}
```

AdminMapper

```
@Mapper
@Repository
public interface AdminMapper extends BaseMapper<Admin> {
}
```

PermissionMapper

```
@Mapper
@Repository
public interface PermissionMapper extends BaseMapper<Permission> {
    @Select("select * from ms_permission where id in (select permission_id from ms_admin_permission where admin_id=#{adminId})")
    List<Permission> findPermissionsByAdminId(Long adminId);
}
```

#### 权限认证

```
@Service
@Slf4j
public class AuthService {

    @Autowired
    private AdminService adminService;

    public boolean auth(HttpServletRequest request, Authentication authentication){
        String requestURI = request.getRequestURI();
        log.info("request url:{}", requestURI);
        //true代表放行      false代表拦截
        Object principal = authentication.getPrincipal();
        if (principal == null || "anonymousUser".equals(principal)){
            //未登录
            return false;
        }
        UserDetails userDetails = (UserDetails) principal;
        String username = userDetails.getUsername();
        Admin admin = adminService.findAdminByUsername(username);
        if (admin == null){
            return false;
        }
        if (admin.getId() == 1){
            //认为是超级管理员
            return true;
        }
        List<Permission> permissions = adminService.findPermissionsByAdminId(admin.getId());
        requestURI = StringUtils.split(requestURI,'?')[0];//不要参数只要请求
        for (Permission permission : permissions) {
            if (requestURI.equals(permission.getPath())){//这里删除权限除了root谁都没有，因为URL上有变量
                log.info("权限通过");
                return true;
            }
        }
        return false;
    }
}
```

> 扩展：添加角色，用户拥有多个角色，一个角色拥有多个权限